from typing import Set, List, Tuple, Iterable
import itertools


COLS = "abcdefgh"
ROWS = "12345678"


class CannotPlace8Queens(Exception):
    pass


def is_position_threatened(placed_queens: Set[str], position: str) -> bool:
    """ Check if position is threatened by already placed queens """
    col, row = position[0], position[1]
    if any(queen_col == col or queen_row == row for queen_col, queen_row in placed_queens):
        return True
    col_index, row_index = COLS.index(position[0]), int(position[1]) - 1
    for i in range(-8, 8):
        c = col_index + i
        r1, r2 = row_index + i, row_index - i
        if c in range(8) and r1 in range(8):
            if COLS[c] + ROWS[r1] in placed_queens:
                return True
        if c in range(8) and r2 in range(8):
            if COLS[c] + ROWS[r2] in placed_queens:
                return True
    return False


def place_queens(placed: Set[str]) -> Set[str]:
    """ Place queens on chess board so that no 2 queens threaten each other"""
    if not verify_placed_are_valid(placed):
        return set()
    uncovered_col, uncovered_row = set(COLS), set(ROWS)
    for col, row in placed:
        uncovered_col.remove(col)
        uncovered_row.remove(row)

    uncovered_col = list(uncovered_col)
    uncovered_row = list(uncovered_row)
    for c in itertools.permutations(uncovered_col, len(uncovered_col)):
        for r in itertools.permutations(uncovered_row, len(uncovered_row)):
            try:
                placed_queens = try_placing_queens(placed, c, r)
                return placed_queens
            except CannotPlace8Queens:
                pass
    return set()


def try_placing_queens(already_placed: Set[str], uncovered_cols: Iterable[str],
                       uncovered_rows: Iterable[str]) -> Set[str]:
    places_for_queens = already_placed.copy()
    for col in uncovered_cols:
        for row in uncovered_rows:
            if not is_position_threatened(places_for_queens, col + row):
                places_for_queens.add(col + row)
                if len(places_for_queens) == 8:
                    return places_for_queens
                break
    raise CannotPlace8Queens


def verify_placed_are_valid(placed: Set[str]) -> bool:
    for queen in placed:
        if is_position_threatened(placed - {queen}, queen):
            return False
    return True


if __name__ == '__main__':
    # Auto-generated by checkio for testing
    from itertools import combinations

    THREATS = {c + r: set(
        [c + ROWS[k] for k in range(8)] +
        [COLS[k] + r for k in range(8)] +
        [COLS[k] + ROWS[i - j + k] for k in range(8) if 0 <= i - j + k < 8] +
        [COLS[k] + ROWS[- k + i + j] for k in range(8) if 0 <= - k + i + j < 8])
               for i, r in enumerate(ROWS) for j, c in enumerate(COLS)}

    def check_coordinate(coor):
        c, r = coor
        return c in COLS and r in ROWS

    def checker(func, placed, is_possible):
        user_set = func(placed.copy())
        if not all(isinstance(c, str) and len(c) == 2 and check_coordinate(c) for c in user_set):
            print("Wrong Coordinates")
            return False
        threats = []
        for f, s in combinations(user_set.union(placed), 2):
            if s in THREATS[f]:
                threats.append([f, s])
        if not is_possible:
            if user_set:
                print("Hm, how did you place them?")
                return False
            else:
                return True
        if not all(p in user_set for p in placed):
            print("You forgot about placed queens.")
            return False
        if is_possible and threats:
            print("I see some problems in this placement.")
            return False
        return True

    assert checker(place_queens, {"b2", "c4", "d6", "e8"}, True), "1st Example"
    assert checker(place_queens, {"b2", "c4", "d6", "e8", "a7", "g5"}, False), "2nd Example"

